<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="a personal website">
    
    <link rel="shortcut icon" href="https://jonjau.github.io/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>Monads, Applicatives and Functors in Haskell</title>
</head>
<body><header id="banner">
    <h2>
        <div style="
        display: inline-block;
        height: 20px;
        width: 20px;
        background-color: #1D7464;
        "></div>
        <a href="https://jonjau.github.io">Jonathan Jauhari</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/posts/" title="posts">posts</a>
            </li><li>
                <a href="/projects/" title="projects">projects</a>
            </li><li>
                <a href="/about/" title="about">about</a>
            </li>
        </ul>
    </nav>
</header>
<hr/>
        <main id="content">
<article>
    <header id="post-header">
        <h1>Monads, Applicatives and Functors in Haskell</h1><time>October 7, 2020</time></header><p>This is my summary of Chapter 11 and 12 of
<a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a>,
a great introduction to functional programming and Haskell. I&rsquo;ve found its
explanation of monads, by far the most notorious of category theory jargon
(monoids and functors being runner-ups), to be about as intuitive as monad
explanations can get.</p>
<p>This is hardly comprehensive, but these notes touch on most of the main
concepts of the Haskell type system (that I&rsquo;m aware of&hellip;).</p>
<h2 id="values">Values</h2>
<p>Values have types. Types can be inferred:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;f&#39;</span>       <span style="color:#75715e">-- x has (inferred) type Char</span>
<span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#39;f&#39;</span>,<span style="color:#e6db74">&#39;g&#39;</span>] <span style="color:#75715e">-- y has (inferred) type [Char], a list of Char&#39;s</span>
</code></pre></div><p>Use <code>:t</code> in <a href="https://docs.haskellstack.org/en/stable/ghci/">GHCi</a>
to check the type of a value, e.g. <code>:t 'f'</code> will give <code>f :: Char</code>, where
<code>::</code> can be read as &lsquo;type of&rsquo; or &lsquo;has type&rsquo;. There is also
<a href="%5Bhoogle.com%5D(https://hoogle.haskell.org)">Hoogle</a>.
Though Haskell is able to infer types very well, it is good practice that
top-level definitions are explicitly type-annotated:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- the type declaration doesn&#39;t have to sit on top of the definition either</span>
<span style="color:#a6e22e">x</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Char</span>
<span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;f&#39;</span>
</code></pre></div><h2 id="functions">Functions</h2>
<p>Functions map values to values. Since functions themselves are values
(<a href="https://en.wikipedia.org/wiki/First-class_citizen">&ldquo;first-class citizens&rdquo;</a>),
they too have types. <code>f :: p -&gt; p</code> can be read as &ldquo;f takes a p and returns a p&rdquo;.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#a6e22e">f</span> <span style="color:#f92672">::</span> p <span style="color:#f92672">-&gt;</span> p
<span style="color:#a6e22e">f</span> x <span style="color:#f92672">=</span> x            <span style="color:#75715e">-- no-op</span>

<span style="color:#a6e22e">g</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Eq</span> a <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">g</span> x y <span style="color:#f92672">=</span> x <span style="color:#f92672">==</span> y      <span style="color:#75715e">-- equality, g is pretty much (==)</span>
</code></pre></div><p>The second function <code>g</code> has a type constraint: it takes two arguments of a type
<code>a</code> that must have properly defined equality, such that it is of the
typeclass <code>Eq</code> (more on this later), e.g. <code>Int</code>. This is parametric
polymorphism, with especially lightweight syntax.</p>
<p>Note functions in Haskell are automatically
<a href="https://en.wikipedia.org/wiki/Currying">curried</a> (like partial application,
but one argument at at time) &ndash; a function that takes two arguments, like <code>g</code>,
is still a valid function when only one of its arguments is given:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- (g 3) is a function that expects one argument, and returns true if it equals</span>
<span style="color:#75715e">-- 3 and false otherwise. This returns all the items equal to 3 in the list:</span>
<span style="color:#a6e22e">filter</span> (g <span style="color:#ae81ff">3</span>) [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>,<span style="color:#ae81ff">3</span>] <span style="color:#75715e">-- evaluates to [3,3]</span>
</code></pre></div><h2 id="defining-data-types">Defining (data) types</h2>
<p><code>data</code> defines an algebraic data type
(<a href="https://en.wikipedia.org/wiki/Algebraic_data_type">ADT</a>):</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">TrafficLight</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Red</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Yellow</span> <span style="color:#f92672">|</span> <span style="color:#66d9ef">Green</span>

<span style="color:#75715e">-- the value of type Person may be constructed with: Person &#34;bob&#34; 9</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Person</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Person</span> <span style="color:#66d9ef">String</span> <span style="color:#66d9ef">Int</span>
</code></pre></div><p>On the left is the name of the type, and on the right are data constructors
(or type constructors). Type constructors are like functions: they may take
parameters and are automatically curried. Types may have the same name as
their data constructor(s). Note that type constructors do not have a function
body), they simply construct types.</p>
<p><code>newtype</code> defines new types out of existing data types:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- this is record syntax in Haskell</span>
<span style="color:#66d9ef">data</span> <span style="color:#66d9ef">ZipList</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">ZipList</span> { getZipList <span style="color:#f92672">::</span> [a] }

<span style="color:#75715e">-- faster (no wrapping/unwrapping overhead) and equivalent:</span>
<span style="color:#66d9ef">newtype</span> <span style="color:#66d9ef">ZipList</span> a <span style="color:#f92672">=</span> <span style="color:#66d9ef">ZipList</span> { getZipList <span style="color:#f92672">::</span> [a] }
</code></pre></div><p>It was made exactly for cases when we want to just take one type and
wrap it in something to present it as another type.
<code>data</code> can only and should be replaced with <code>newtype</code> if the type has exactly
one constructor with exactly one field inside it. Contrast this with:</p>
<h2 id="type-synonyms">Type synonyms</h2>
<p><code>type</code> defines a type alias. Wherever one can be used, the other can
take its place. No data constructor is defined.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">type</span> <span style="color:#66d9ef">MyStr</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">String</span>
</code></pre></div><h2 id="typeclasses">Typeclasses</h2>
<p>A typeclass takes a type variable and describes what can be done to it;
typeclasses are like interfaces.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- What does it mean to have well-defined equality?</span>
<span style="color:#75715e">-- It must define the following functions:</span>
<span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Eq</span> a <span style="color:#66d9ef">where</span>
    (<span style="color:#f92672">==</span>) <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
    (<span style="color:#f92672">/=</span>) <span style="color:#f92672">::</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
    x <span style="color:#f92672">==</span> y <span style="color:#f92672">=</span> not (x <span style="color:#f92672">/=</span> y)    <span style="color:#75715e">-- this is the default implementation for (==)</span>
    x <span style="color:#f92672">/=</span> y <span style="color:#f92672">=</span> not (x <span style="color:#f92672">==</span> y)    <span style="color:#75715e">-- and for (/=), note the indirect recursion.</span>
</code></pre></div><p>typeclasses allow for polymorphism:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- constraints check out: works for any type a that is an instance of Eq</span>
<span style="color:#a6e22e">equal</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">Eq</span> a <span style="color:#f92672">=&gt;</span> a <span style="color:#f92672">-&gt;</span> a <span style="color:#f92672">-&gt;</span> <span style="color:#66d9ef">Bool</span>
<span style="color:#a6e22e">equal</span> x y <span style="color:#f92672">=</span> x <span style="color:#f92672">==</span> y
</code></pre></div><p>types can be made instances of typeclasses:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- How does a TrafficLight have well-defined equality?</span>
<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Eq</span> <span style="color:#66d9ef">TrafficLight</span> <span style="color:#66d9ef">where</span>
    <span style="color:#66d9ef">Red</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">Red</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
    <span style="color:#66d9ef">Green</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">Green</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
    <span style="color:#66d9ef">Yellow</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">Yellow</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">True</span>
    <span style="color:#66d9ef">_</span> <span style="color:#f92672">==</span> <span style="color:#66d9ef">_</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">False</span>
</code></pre></div><blockquote>
<p>If you want to see what the instances of a typeclass are, just do <code>:info</code>
(or <code>:i</code>) on a typeclass in GHCI. Typing <code>:info Num</code> will show which
functions the typeclass defines and it will give you a list of the types in
the typeclass. <code>:info</code> works for types and type constructors too.</p>
</blockquote>
<h2 id="monoids">Monoids</h2>
<p>A monoid is a type for which you have a well-defined associative binary
function e.g. <code>(*)</code> in <code>(1*(2*3) == (1*2)*3)</code> and a value which acts as an
identity with respect to that function. When something acts as an identity
with respect to a function, it means that when called with that function and
some other value, the result is always equal to that other value:</p>
<blockquote>
<p><code>1</code> is the identity with respect to <code>*</code>
and <code>[]</code> is the identity with respect to <code>++</code>.
Any number multiplied by 1 is itself, and appending the empty list to any
list yields the list. So <code>1</code> and <code>[]</code> are <code>mempty</code>s and <code>*</code> and <code>++</code> are
<code>mappend</code>s for the <code>Num</code> and <code>[]</code> monoids, respectively.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Monoid</span> m <span style="color:#66d9ef">where</span>
    mempty <span style="color:#f92672">::</span> m <span style="color:#75715e">-- polymorphic constant: the identity value (e.g. 1 w.r.t *)</span>
    mappend <span style="color:#f92672">::</span> m <span style="color:#f92672">-&gt;</span> m <span style="color:#f92672">-&gt;</span> m <span style="color:#75715e">-- takes two monoid values and returns a third</span>
    mconcat <span style="color:#f92672">::</span> [m] <span style="color:#f92672">-&gt;</span> m
    mconcat <span style="color:#f92672">=</span> foldr mappend mempty <span style="color:#75715e">-- default implementation!</span>
</code></pre></div><p>Monoid laws (surrounding a function with backticks (`) allows infix calling):</p>
<ul>
<li><code>mempty `mappend` x = x</code></li>
<li><code>x `mappend` mempty = x</code></li>
<li><code>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</code></li>
</ul>
<p>Monoid instances:</p>
<ul>
<li>lists are monoids, where <code>mempty = []</code>, <code>mappend = (++)</code></li>
<li>numbers can be monoids in multiple ways with <code>0</code> and <code>+</code>, and <code>1</code> and <code>*</code></li>
<li>booleans can be monoids in two ways with <code>False</code> and <code>OR</code> (<code>newtype</code>&rsquo;d as <code>Any</code>
in <code>Data.Monoid</code>), and <code>True</code> and <code>AND</code>
(<code>newtype</code>&rsquo;d as <code>All</code> in <code>Data.Monoid</code>).</li>
</ul>
<h2 id="functors">Functors</h2>
<p>What can I map functions over? I can map functions over a
&ldquo;computational context&rdquo;.</p>
<blockquote>
<ul>
<li>functors are things that can be mapped over (e.g. lists, Maybes).</li>
<li>functors are instances of the typeclass <code>Functor</code>.</li>
<li><code>fmap</code> works like <code>map</code>, but is more general (works on all functors, not
just lists).</li>
<li><code>(&lt;$&gt;)</code> is an infix synonym of <code>fmap</code>.</li>
<li>&ldquo;normal&rdquo; functors support mapping &ldquo;normal&rdquo; functions over them.
&ldquo;normal&rdquo; here meaning dealing with plain old values, i.e. non-monadic
values.</li>
</ul>
</blockquote>
<p>Technically any type can be defined to be a Functor, whether it makes sense
is a separate issue. Examples of where it makes sense:</p>
<ul>
<li>mapping a function over a list of <code>a</code>s means applying the function to each
<code>a</code> in the list. The computational context here is the &ldquo;repetition&rdquo;.</li>
<li>mapping a function over a <code>Maybe a</code>, means applying the function to the <code>a</code>
if it&rsquo;s there, or evaluating to <code>Nothing</code> if it&rsquo;s not.
The computational context here is the &ldquo;optionality&rdquo;.</li>
</ul>
<blockquote>
<p>A <code>Maybe a</code> is either a <code>Just a</code> or a <code>Nothing</code> &ndash; it has two data
constructors.</p>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- these two expressions are equivalent, they both evaluate to [4,5,6,7,8]</span>
<span style="color:#a6e22e">fmap</span> (<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>) [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>]
(<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;$&gt;</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>,<span style="color:#ae81ff">5</span>]

<span style="color:#75715e">-- a Maybe supports mapping (+3), a normal function as follows:</span>
<span style="color:#a6e22e">fmap</span> (<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>) (<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">5</span>) <span style="color:#75715e">-- evaluates to (Just 8)</span>
(<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#66d9ef">Nothing</span>   <span style="color:#75715e">-- evaluates to Nothing</span>
</code></pre></div><blockquote>
<p>Note how the values end up inside the context (wrapped in the List/Maybe).
In general there is not a nice function you can use to recover the <code>a</code> once
it is inside a functor (or an <code>Applicative</code>, or a <code>Monad</code>). That is,
<code>Functor</code> does not require its instances to define what it means to unwrap
a the context to return the value.</p>
<p>This is by design. For instance, unwrapping a <code>Maybe</code> to try and get the value
inside of it doesn&rsquo;t always make sense: what would <code>Nothing</code> unwrap into?
<strong>&hellip; NullPointerException</strong>. In the case of the <code>IO</code> monad, whose
computational context I think of as &ldquo;impurity&rdquo;, it is even more finicky to
extract a pure value from a monadic one. In any case you will invite
runtime errors.</p>
</blockquote>
<p>Anyway, here are the Functor laws:</p>
<ol>
<li><code>fmap id = id</code>, where <code>id</code> is <code>\x -&gt; x</code>: &ldquo;return what was passed&rdquo;</li>
<li><code>fmap (f . g) = fmap f . fmap g</code>, or equivalently,<br>
<code>fmap (f . g) F = fmap f (fmap g F)</code>.</li>
</ol>
<p>The <code>\x y -&gt; x + y</code> syntax is a lambda expression, here it defines an
anonymous function that takes two arguments x and y and returns their sum.
The <code>.</code> syntax is
<a href="https://en.wikipedia.org/wiki/Function_composition">function composition</a> as
in mathematics: <code>(f . g) x</code> is equivalent to <code>f (g x)</code>.</p>
<h2 id="applicative-functors">Applicative functors</h2>
<p>What if I want to map normal functions in a functor over another functor:
&ldquo;to reach into the context, compute, and return the value in that context&rdquo;?
Those functors must be applicative.</p>
<blockquote>
<ul>
<li>applicative values are values with &ldquo;added context&rdquo;, e.g. <code>Just 5</code></li>
<li>applicative functors support mapping functions inside functors over them</li>
<li>applicative functors are functors, and they are instances of the
<code>Applicative</code> typeclass. It defines <code>pure</code> and <code>(&lt;*&gt;)</code>.</li>
<li><code>pure</code> takes a value and returns that value in the applicative functor
(&ldquo;wrapped in the minimal context&rdquo;)</li>
<li><code>&lt;*&gt;</code> (infix) takes a functor with a function in it and another functor,
and extracts the function from the first functor and maps it over the
second one.</li>
</ul>
</blockquote>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- mapping functions in a functor over values in a functor</span>
<span style="color:#75715e">-- (the same type of functor!)</span>
[(<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>), (<span style="color:#ae81ff">1</span><span style="color:#f92672">-</span>), (<span style="color:#f92672">^</span><span style="color:#ae81ff">2</span>)] <span style="color:#f92672">&lt;*&gt;</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>] <span style="color:#75715e">-- [4,5,6,7,0,-1,-2,-3,1,4,9,16]</span>
[(<span style="color:#f92672">==</span><span style="color:#ae81ff">3</span>)] <span style="color:#f92672">&lt;*&gt;</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>,<span style="color:#ae81ff">4</span>]            <span style="color:#75715e">-- [False, False, True, False]</span>

(<span style="color:#66d9ef">Just</span> (<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>)) <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#66d9ef">Nothing</span>    <span style="color:#75715e">-- Nothing</span>
(<span style="color:#66d9ef">Just</span> (<span style="color:#ae81ff">3</span><span style="color:#f92672">-</span>)) <span style="color:#f92672">&lt;*&gt;</span> (<span style="color:#66d9ef">Just</span> (<span style="color:#ae81ff">7</span>)) <span style="color:#75715e">-- Just (-4)</span>
<span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#66d9ef">Nothing</span>        <span style="color:#75715e">-- Nothing</span>
</code></pre></div><p>Applicative functor laws (this is where the analogies fall apart):</p>
<ol>
<li><code>pure id &lt;*&gt; v = v</code></li>
<li><code>pure f &lt;*&gt; pure x = pure (f x)</code></li>
<li><code>u &lt;*&gt; pure y = pure ($ y) &lt;*&gt; u</code></li>
<li><code>pure (.) &lt;*&gt; u &lt;*&gt; v &lt;*&gt; w = u &lt;*&gt; (v &lt;*&gt; w)</code></li>
</ol>
<h2 id="monads">Monads</h2>
<p>What if I have a value in a context, <code>m a</code>, and want apply to it a function
that takes a normal <code>a</code> and returns a value in that context?
How do you apply a function of type <code>a -&gt; m b</code> to a value of type <code>m a</code>?</p>
<p>Another take on monads from a similarly great book:
<a href="http://book.realworldhaskell.org/read/monads.html">a programmable semicolon</a>.</p>
<blockquote>
<ul>
<li>monads are just applicative functors that support <code>&gt;&gt;=</code> (read as &ldquo;bind&rdquo;)</li>
<li><code>&gt;&gt;=</code> is like function application, only instead of taking a normal value
and feeding it to a normal function, it takes a monadic value (that is,
a value with a context) and feeds it to a function that takes a normal
value but returns a monadic value.</li>
<li>a <code>Monad</code>&rsquo;s <code>return</code> is the same as an <code>Applicative</code>&rsquo;s <code>pure</code>,
just a different name.</li>
</ul>
</blockquote>
<p>The most useful monad: the <code>IO</code> monad (again, it is also an Applicative and a
Functor). Sequencing operations one after the other (functions) is possible
in the IO monad. This looks like imperative programming and is indeed necessary
when dealing with IO operations, which are inherently
<a href="https://en.wikipedia.org/wiki/Functional_purity">impure</a>.</p>
<p>In a way, since the fact that potential side effects from the <code>IO</code> operations
are clearly in laid out in the type system, they are not really side effects,
and this makes the whole program easier to reason with. It is said that this
makes Haskell a purely functional language still.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- we can finally write Hello World :)</span>
<span style="color:#75715e">-- f &gt;&gt; g is the same as f &gt;&gt;= \_ -&gt; g</span>
<span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> ()
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span>
    putStr <span style="color:#e6db74">&#34;Hello&#34;</span> <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span><span style="color:#66d9ef">_</span> <span style="color:#f92672">-&gt;</span>
        putStr <span style="color:#e6db74">&#34; ...World&#34;</span> <span style="color:#f92672">&gt;&gt;</span>
            putStrLn <span style="color:#e6db74">&#34;in Haskell&#34;</span>

<span style="color:#75715e">-- demonstrating the I in IO, as well as monad syntax:</span>
<span style="color:#75715e">-- a function that fetches user input, prints it out and returns it.</span>
<span style="color:#a6e22e">main</span> <span style="color:#f92672">::</span> <span style="color:#66d9ef">IO</span> <span style="color:#66d9ef">String</span>
<span style="color:#a6e22e">main</span> <span style="color:#f92672">=</span>
    putStrLn <span style="color:#e6db74">&#34;Who?&#34;</span> <span style="color:#f92672">&gt;&gt;</span>
        getLine <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>name <span style="color:#f92672">-&gt;</span>
            putStrLn (<span style="color:#e6db74">&#34;Oh Hello &#34;</span> <span style="color:#f92672">++</span> name) <span style="color:#f92672">&gt;&gt;</span>
                return name
</code></pre></div><p>The distinction with applicative functors is very slight.
<strong>Most common functors are applicative and are monads</strong>, e.g.
<code>[]</code>, <code>Maybe</code>, <code>State</code>, <code>IO</code></p>
<p><a href="https://en.wikibooks.org/wiki/Haskell/do_notation">do-blocks</a>
are syntactic sugar to deal with monads, to do away with nesting. See below.</p>
<h2 id="syntax">Syntax</h2>
<p>To make a point about the syntax, all of these functions are exactly equivalent:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- list comprehension</span>
<span style="color:#75715e">-- lists get their own special shorthand syntax, comprehensions like in Python.</span>
<span style="color:#a6e22e">e1</span> <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> [(a,a,<span style="color:#66d9ef">Int</span>)]
<span style="color:#a6e22e">e1</span> lst <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
    <span style="color:#66d9ef">in</span>  [(x,y,c) <span style="color:#f92672">|</span> x <span style="color:#f92672">&lt;-</span> lst, y <span style="color:#f92672">&lt;-</span> lst]

<span style="color:#75715e">-- do-block: &#34;implicit&#34; (&gt;&gt;=)&#39;s</span>
<span style="color:#a6e22e">e2</span> <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> [(a,a,<span style="color:#66d9ef">Int</span>)]
<span style="color:#a6e22e">e2</span> lst <span style="color:#f92672">=</span> <span style="color:#66d9ef">do</span>
    x <span style="color:#f92672">&lt;-</span> lst
    y <span style="color:#f92672">&lt;-</span> lst
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
    return (x,y,c)

<span style="color:#75715e">-- sugarless: binding monadic operations explicitly</span>
<span style="color:#a6e22e">e3</span> <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> [(a,a,<span style="color:#66d9ef">Int</span>)]
<span style="color:#a6e22e">e3</span> lst <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">in</span>
    lst <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span>
        lst <span style="color:#f92672">&gt;&gt;=</span> <span style="color:#a6e22e">\</span>y <span style="color:#f92672">-&gt;</span>
            pure (x,y,c)

<span style="color:#75715e">-- maximum golf: remember (&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</span>
<span style="color:#75715e">-- implicitly the &lt;$&gt; bit is evaluated first to get a list of functions.</span>
<span style="color:#a6e22e">e4</span> <span style="color:#f92672">::</span> [a] <span style="color:#f92672">-&gt;</span> [(a,a,<span style="color:#66d9ef">Int</span>)]
<span style="color:#a6e22e">e4</span> lst <span style="color:#f92672">=</span>
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">in</span>
    (<span style="color:#a6e22e">\</span>x y <span style="color:#f92672">-&gt;</span> (x,y,c)) <span style="color:#f92672">&lt;$&gt;</span> lst <span style="color:#f92672">&lt;*&gt;</span> lst
</code></pre></div><h2 id="types-and-instances-of-functors-et-al">Types and instances of functors et al</h2>
<ul>
<li><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>, literally <code>fmap</code> but just for lists</li>
<li><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is a functor :@1</li>
<li><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is a functor</li>
<li><code>pure :: a -&gt; f a</code>, where f is an applicative functor</li>
<li><code>(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is an applicative functor</li>
<li><code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>, where m is a monad</li>
<li><code>(&gt;&gt;) :: m a -&gt; m b -&gt; m b</code>, where m is a monad</li>
<li><code>return :: a -&gt; m a</code>, where m is a monad</li>
</ul>
<p><a href="https://wiki.haskell.org/Lifting">&ldquo;lifting&rdquo;</a>:
<code>(-&gt;)</code> is right-applicative, so
<code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> is equivalent, and emphasises the &ldquo;lift&rdquo;,
likewise for <code>pure</code> et al.</p>
<p>this is how lists are instances of Functor:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- [] here is A TYPE CONSTRUCTOR, i.e. the f in Functor f</span>
<span style="color:#75715e">-- not the literal for an empty list.</span>
<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#66d9ef">[]</span> <span style="color:#66d9ef">where</span>
    fmap <span style="color:#f92672">=</span> map
</code></pre></div><p>and Maybe:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> <span style="color:#66d9ef">Maybe</span> <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Just</span> x) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Just</span> (f x)
    fmap f <span style="color:#66d9ef">Nothing</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">Nothing</span>
</code></pre></div><p>and Either:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">data</span> <span style="color:#66d9ef">Either</span> a b <span style="color:#f92672">=</span> <span style="color:#66d9ef">Left</span> a <span style="color:#f92672">|</span> <span style="color:#66d9ef">Right</span> b

<span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Functor</span> (<span style="color:#66d9ef">Either</span> a) <span style="color:#66d9ef">where</span>
    fmap f (<span style="color:#66d9ef">Right</span> x) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Right</span> (f x)
    fmap f (<span style="color:#66d9ef">Left</span> x) <span style="color:#f92672">=</span> <span style="color:#66d9ef">Left</span> x
</code></pre></div><p><code>Either a</code> is a type constructor that takes 1 parameter, which is what the
Functor typeclass expects.</p>
<p>Functions are in fact monads too:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">instance</span> <span style="color:#66d9ef">Applicative</span> ((<span style="color:#f92672">-&gt;</span>) r) <span style="color:#66d9ef">where</span>
    pure x <span style="color:#f92672">=</span> (<span style="color:#a6e22e">\</span><span style="color:#66d9ef">_</span> <span style="color:#f92672">-&gt;</span> x)
    f <span style="color:#f92672">&lt;*&gt;</span> g <span style="color:#f92672">=</span> <span style="color:#a6e22e">\</span>x <span style="color:#f92672">-&gt;</span> f x (g x)

<span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> (<span style="color:#f92672">+</span>) <span style="color:#f92672">&lt;$&gt;</span> (<span style="color:#f92672">+</span><span style="color:#ae81ff">3</span>) <span style="color:#f92672">&lt;*&gt;</span> (<span style="color:#f92672">*</span><span style="color:#ae81ff">100</span>) <span style="color:#f92672">$</span> <span style="color:#ae81ff">5</span>
<span style="color:#ae81ff">508</span>
</code></pre></div><h2 id="in-action">In action</h2>
<p>Golfing once again&hellip;</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#75715e">-- equivalently:</span>
<span style="color:#75715e">-- getZipList $ fmap (+) (ZipList [1,2,3]) &lt;*&gt; (ZipList [100,10,20])</span>
<span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> getZipList <span style="color:#f92672">$</span> (<span style="color:#f92672">+</span>) <span style="color:#f92672">&lt;$&gt;</span> <span style="color:#66d9ef">ZipList</span> [<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">3</span>] <span style="color:#f92672">&lt;*&gt;</span> <span style="color:#66d9ef">ZipList</span> [<span style="color:#ae81ff">100</span>,<span style="color:#ae81ff">10</span>,<span style="color:#ae81ff">20</span>]
[<span style="color:#ae81ff">101</span>, <span style="color:#ae81ff">12</span>, <span style="color:#ae81ff">23</span>]

<span style="color:#75715e">-- implicitly, this is (fmap &lt;$&gt; [(+2,(*2))]) &lt;*&gt; [Just 10, Just 20] :@1</span>
<span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> fmap <span style="color:#f92672">&lt;$&gt;</span> [(<span style="color:#f92672">+</span><span style="color:#ae81ff">2</span>),(<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)] <span style="color:#f92672">&lt;*&gt;</span> [<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">10</span>, <span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">20</span>]
[<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">12</span>,<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">22</span>,<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">20</span>,<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">40</span>]

<span style="color:#a6e22e">ghci</span><span style="color:#f92672">&gt;</span> (fmap (<span style="color:#f92672">*</span><span style="color:#ae81ff">2</span>)) <span style="color:#f92672">&lt;$&gt;</span> [<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">1</span>, <span style="color:#66d9ef">Nothing</span>, <span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">3</span>]
[<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">2</span>,<span style="color:#66d9ef">Nothing</span>,<span style="color:#66d9ef">Just</span> <span style="color:#ae81ff">6</span>]

</code></pre></div><h2 id="class-constraints">Class constraints</h2>
<p>Class constraints can appear in (type)class declarations vs instance
declarations, as in <code>(Eq m) =&gt; Eq (classOrInstanceName m)</code>.</p>
<ul>
<li>In class declarations, they are used for making a typeclass a subclass of
another typeclass.</li>
<li>In instance declarations, they are used to express requirements about the
contents of some type.</li>
</ul>
<p>For instance, we might require the contents of a Maybe, which is a concrete
type to also be part of the Eq typeclass. Note the Maybe is a type constructor.</p>
<h2 id="kinds">Kinds</h2>
<p><a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">Few languages</a>
have type systems that allow access to higher-kinded types (e.g. Monads).
Haskell lets you see the kinds of types too. I have yet to realise where
this might be useful.</p>
<p>Kinds are to types what types are to values. Find out kind of a type with
<code>:k</code> in GHCi.</p>
<p><code>*</code> means concrete type:</p>
<ul>
<li><code>Int :: *</code></li>
<li><code>Maybe :: * -&gt; *</code></li>
<li><code>Maybe Int :: *</code></li>
<li><code>Either :: * -&gt; * -&gt; *</code></li>
</ul>
<p>I haven&rsquo;t quite grasped this, but it&rsquo;s interesting regardless:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-haskell" data-lang="haskell"><span style="color:#66d9ef">class</span> <span style="color:#66d9ef">Tofu</span> t <span style="color:#66d9ef">where</span>
    tofu <span style="color:#f92672">::</span> j a <span style="color:#f92672">-&gt;</span> t a j
</code></pre></div><p>If <code>t</code> is an instance of <code>Tofu</code>, what would its kind be?</p>
<ul>
<li><code>j a</code> is the type of the value of the first parameter of <code>tofu</code>, so
its kind must be <code>*</code>, i.e. it is a concrete type.</li>
<li>Assuming <code>a</code> is of kind <code>*</code>, <code>j</code> has kind <code>* -&gt; *</code>.</li>
<li><code>t a j</code> must be a concrete type, and since it takes two types <code>a</code> and <code>j</code>,
whose kinds we inferred above, <code>t</code> has kind <code>* -&gt; (* -&gt; *) -&gt; *</code>.</li>
</ul>
<p>So, <code>t</code> takes a concrete type <code>a</code>, a type constructor <code>j</code> that takes a concrete
type, and produces a concrete type.</p>
</article>

        </main><footer id="footer">
    Copyright © 2020 Jonathan Jauhari
</footer>
</body>
</html>
