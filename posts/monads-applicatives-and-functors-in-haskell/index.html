<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="a personal website">
    
    <link rel="shortcut icon" href="https://jonjau.github.io/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>Monads, Applicatives and Functors in Haskell</title>
</head>
<body><header id="banner">
    <h2>
        <div style="
        display: inline-block;
        height: 20px;
        width: 20px;
        background-color: #1D7464;
        "></div>
        <a href="https://jonjau.github.io">Jonathan Jauhari</a></h2>
    <nav>
        <ul>
            <li>
                <a href="/posts/" title="posts">posts</a>
            </li><li>
                <a href="/projects/" title="projects">projects</a>
            </li><li>
                <a href="/about/" title="about">about</a>
            </li>
        </ul>
    </nav>
</header>
<hr/>
        <main id="content">
<article>
    <header id="post-header">
        <h1>Monads, Applicatives and Functors in Haskell</h1><time>October 7, 2020</time></header><p>This is a brief summary of Chapter 11 and 12 of
<a href="http://learnyouahaskell.com/chapters">Learn You a Haskell for Great Good!</a>,
a great introduction to functional programming and Haskell. I&rsquo;ve found its
explanation of monads, by far the most notorious of category theory jargon
(monoids and functors being runner-ups), to be about as intuitive as monad
explanations can get. Here are some notes I made:</p>
<h2 id="values">Values</h2>
<p>Values have types. Types can be inferred:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">x</span> <span class="ow">=</span> <span class="sc">&#39;f&#39;</span>       <span class="c1">-- x has (inferred) type Char</span>
<span class="nf">y</span> <span class="ow">=</span> <span class="p">[</span><span class="sc">&#39;f&#39;</span><span class="p">,</span><span class="sc">&#39;g&#39;</span><span class="p">]</span> <span class="c1">-- y has (inferred) type [Char]</span>
</code></pre></div><p>Use <code>:t</code> in GHCi to check the type of a value. <code>::</code> can be read as &lsquo;type of&rsquo;.</p>
<h2 id="functions">Functions</h2>
<p>Functions map values to values. Since functions themselves are values,
they too have types.</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="nf">f</span> <span class="n">x</span> <span class="ow">=</span> <span class="n">x</span>          <span class="c1">-- f :: p -&gt; p</span>
<span class="nf">g</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>    <span class="c1">-- g :: Num a =&gt; a -&gt; a -&gt; a</span>
</code></pre></div><p>The second function has a type constraint: it takes two arguments of a type
<code>a</code> that must be a type of number, e.g. <code>Int</code>. Note functions in Haskell are
automatically <a href="https://en.wikipedia.org/wiki/Currying">curried</a> (like partial
application, but one argument at at time).</p>
<h2 id="defining-data-types">Defining (data) types</h2>
<p><code>data</code> defines an algebraic data type (ADT) &ldquo;from scratch&rdquo;:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">TrafficLight</span> <span class="ow">=</span> <span class="kt">Red</span> <span class="o">|</span> <span class="kt">Yellow</span> <span class="o">|</span> <span class="kt">Green</span>
<span class="kr">data</span> <span class="kt">Person</span> <span class="ow">=</span> <span class="kt">Person</span> <span class="kt">String</span> <span class="kt">Int</span>
</code></pre></div><p>On the left is the name of the type, and on the right are data constructors
(or type constructors). Type constructors are like functions: they may take
parameters and are automatically curried. Types may have the same name as
their data constructor(s). Note that type constructors do not define any
computation, they simply construct types.</p>
<p><code>newtype</code> defines new types out of existing data types:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- this is record syntax in Haskell</span>
<span class="kr">data</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">{</span> <span class="n">getZipList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>

<span class="c1">-- faster (no wrapping/unwrapping overhead) and equivalent:</span>
<span class="kr">newtype</span> <span class="kt">ZipList</span> <span class="n">a</span> <span class="ow">=</span> <span class="kt">ZipList</span> <span class="p">{</span> <span class="n">getZipList</span> <span class="ow">::</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="p">}</span>
</code></pre></div><p>It was made exactly for cases when we want to just take one type and
wrap it in something to present it as another type.
<code>data</code> can only and should be replaced with <code>newtype</code> if the type has exactly
one constructor with exactly one field inside it.</p>
<h2 id="type-synonyms">Type synonyms</h2>
<p><code>type</code> defines a type alias. Wherever one can be used, the other can
take its place. No data constructor is defined.</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">type</span> <span class="kt">MyStr</span> <span class="ow">=</span> <span class="kt">String</span>
</code></pre></div><h2 id="typeclasses">Typeclasses</h2>
<p>A typeclass takes a type variable and describes what can be done to it;
typeclasses are like interfaces.</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- what does it mean to have well-defined equality?</span>
<span class="kr">class</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="kr">where</span>
    <span class="p">(</span><span class="o">==</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="p">(</span><span class="o">/=</span><span class="p">)</span> <span class="ow">::</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
    <span class="n">x</span> <span class="o">==</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">/=</span> <span class="n">y</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">/=</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">not</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span>
</code></pre></div><p>typeclasses allow for polymorphism:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- constraints check out: works for any type a that is an instance of Eq</span>
<span class="nf">equal</span> <span class="ow">::</span> <span class="kt">Eq</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="kt">Bool</span>
<span class="nf">equal</span> <span class="n">x</span> <span class="n">y</span> <span class="ow">=</span> <span class="n">x</span> <span class="o">==</span> <span class="n">y</span>
</code></pre></div><p>types can be made instances of typeclasses:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- How does a TrafficLight have well-defined equality?</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">TrafficLight</span> <span class="kr">where</span>
    <span class="kt">Red</span> <span class="o">==</span> <span class="kt">Red</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Green</span> <span class="o">==</span> <span class="kt">Green</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kt">Yellow</span> <span class="o">==</span> <span class="kt">Yellow</span> <span class="ow">=</span> <span class="kt">True</span>
    <span class="kr">_</span> <span class="o">==</span> <span class="kr">_</span> <span class="ow">=</span> <span class="kt">False</span>
</code></pre></div><blockquote>
<p>If you want to see what the instances of a typeclass are, just do <code>:info</code>
(or <code>:i</code>) on a typeclass in GHCI. So typing <code>:info Num</code> will show which
functions the typeclass defines and it will give you a list of the types in
the typeclass. <code>:info</code> works for types and type constructors too.</p>
</blockquote>
<h2 id="monoids">Monoids</h2>
<p>A monoid is when you have an associative binary function e.g. (1*(2*3) ==
(1*2)*3) and a value which acts as an identity with respect to that
function. When something acts as an identity with respect to a function, it
means that when called with that function and some other value, the result is
always equal to that other value:</p>
<blockquote>
<p><code>1</code> is the identity with respect to <code>*</code>
and <code>[]</code> is the identity with respect to <code>++</code>.</p>
</blockquote>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Monoid</span> <span class="n">m</span> <span class="kr">where</span>
    <span class="n">mempty</span> <span class="ow">::</span> <span class="n">m</span> <span class="c1">-- polymorphic constant: the identity value (e.g. 1 w.r.t *)</span>
    <span class="n">mappend</span> <span class="ow">::</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="ow">-&gt;</span> <span class="n">m</span> <span class="c1">-- takes two monoid values and returns a third</span>
    <span class="n">mconcat</span> <span class="ow">::</span> <span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="n">m</span>
    <span class="n">mconcat</span> <span class="ow">=</span> <span class="n">foldr</span> <span class="n">mappend</span> <span class="n">mempty</span> <span class="c1">-- default implementation!</span>
</code></pre></div><p>Monoid laws:</p>
<ul>
<li>mempty `mappend` x = x</li>
<li>x `mappend` mempty = x</li>
<li>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</li>
</ul>
<p>Monoid instances:</p>
<ul>
<li>lists are monoids (mempty: [], mappend: (++))</li>
<li>numbers can be monoids in multiple ways with 0 and +, and 1 and *</li>
<li>booleans can be monoids in two ways with False and OR (newtype&rsquo;d as <code>Any</code>
in Data.Monoid), and True and AND (newtype&rsquo;d as <code>All</code> in Data.Monoid).</li>
</ul>
<h2 id="functors">Functors</h2>
<p>What can I map functions over? I can map functions over a
&ldquo;computational context&rdquo;.</p>
<blockquote>
<ul>
<li>functors are things that can be mapped over (lists, Maybes, trees).</li>
<li>functors are instances of the typeclass Functor.</li>
<li><code>fmap</code> works like <code>map</code>, but is more general (works on all functors, not
just lists).</li>
<li><code>(&lt;$&gt;)</code> is an infix synonym of <code>fmap</code>.</li>
<li>&ldquo;normal&rdquo; functors support mapping &ldquo;normal&rdquo; functions over them.</li>
</ul>
</blockquote>
<p>functor laws:</p>
<ul>
<li><code>fmap id = id</code>, where <code>id</code> is <code>\x -&gt; x</code>: &ldquo;return what was passed&rdquo;</li>
<li><code>fmap (f . g) = fmap f . fmap g</code>, equivalently,
<code>fmap (f . g) F = fmap f (fmap g F)</code>.</li>
</ul>
<h2 id="applicative-functors">Applicative functors</h2>
<p>What if I want to map normal functions in a functor over another functor:
&ldquo;to reach into the context, compute, and return the value in that context&rdquo;?
Those functors must be applicative.</p>
<blockquote>
<ul>
<li>applicative values are values with &ldquo;added context&rdquo;, e.g. <code>Just 5</code></li>
<li>applicative functors support mapping functions inside functors over them</li>
<li>applicative functors are functors, and they are instances of the
Applicative typeclasss. It defines pure and (&lt;*&gt;).</li>
<li>pure takes a value and returns that value in the applicative functor
(&ldquo;wrap it in a minimal context that returns that value&rdquo;)</li>
<li>&lt;*&gt; (infix) takes a functor with a function in it and another functor,
and extracts the function from the first functor and maps it over the
second one.</li>
</ul>
</blockquote>
<h2 id="monads">Monads</h2>
<p>What if I have a value with a context, <code>m a</code>, and want apply to it a function
that takes a normal <code>a</code> and returns a value with that context?</p>
<p>How do you apply a function of type <code>a -&gt; m b</code> to a value of type <code>m a</code>?</p>
<blockquote>
<ul>
<li>monads are just applicative functors that support <code>&gt;&gt;=</code> (&ldquo;bind&rdquo;)</li>
<li><code>&gt;&gt;=</code> like function application, only instead of taking a normal value
and feeding it to a normal function, it takes a monadic value (that is,
a value with a context) and feeds it to a function that takes a normal
value but returns a monadic value.</li>
<li><code>return</code> is the same as <code>pure</code>, just a different name.</li>
</ul>
</blockquote>
<p><a href="https://en.wikibooks.org/wiki/Haskell/do_notation">do-blocks</a>
are syntactic sugar to deal with monads, to avoid nesting.</p>
<p>The distinction with applicative functors is very slight.
<strong>Most common functors are applicative and are monads</strong>, e.g.
<code>[]</code>, <code>Maybe</code>, <code>State</code>, <code>IO</code></p>
<h2 id="types-and-instances-of-functors-et-al">Types and instances of functors et al.</h2>
<ul>
<li><code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>, literally <code>fmap</code> but just for lists :@1</li>
<li><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is a functor :@2</li>
<li><code>(&lt;$&gt;) :: (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is a functor</li>
<li><code>pure :: a -&gt; f a</code>, where f is an applicative functor</li>
<li><code>(&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b</code>, where f is an applicative functor</li>
<li><code>(&gt;&gt;=) :: m a -&gt; (a -&gt; m b) -&gt; m b</code>, where m is a monad</li>
<li><code>(&gt;&gt;) :: m a -&gt; m b -&gt; m b</code>, where m is a monad</li>
<li><code>return :: a -&gt; m a</code>, where m is a monad</li>
</ul>
<p>@1: equivalent <code>do</code> block:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">do</span> <span class="n">f</span> <span class="ow">&lt;-</span> <span class="n">fs</span>
   <span class="n">m</span> <span class="ow">&lt;-</span> <span class="n">ms</span>
   <span class="n">pure</span> <span class="p">(</span><span class="n">f</span> <span class="o">&lt;$&gt;</span> <span class="n">m</span><span class="p">)</span>
</code></pre></div><p>@2: <a href="https://wiki.haskell.org/Lifting">&ldquo;lifting&rdquo;</a>:
<code>(-&gt;)</code> is right-applicative, so
<code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> is equivalent, and emphasises the &ldquo;lift&rdquo;,
likewise for <code>pure</code> et al.</p>
<p>this is how lists are instances of Functor:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- [] here is A TYPE CONSTRUCTOR, i.e. the f in Functor f</span>
<span class="c1">-- not the literal for an empty list.</span>
<span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">[]</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="ow">=</span> <span class="n">map</span>
</code></pre></div><p>and Maybe:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Functor</span> <span class="kt">Maybe</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Just</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Just</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="kt">Nothing</span> <span class="ow">=</span> <span class="kt">Nothing</span>
</code></pre></div><p>and Either:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Either</span> <span class="n">a</span> <span class="n">b</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">a</span> <span class="o">|</span> <span class="kt">Right</span> <span class="n">b</span>

<span class="kr">instance</span> <span class="kt">Functor</span> <span class="p">(</span><span class="kt">Either</span> <span class="n">a</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Right</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Right</span> <span class="p">(</span><span class="n">f</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">fmap</span> <span class="n">f</span> <span class="p">(</span><span class="kt">Left</span> <span class="n">x</span><span class="p">)</span> <span class="ow">=</span> <span class="kt">Left</span> <span class="n">x</span>
</code></pre></div><p><code>Either a</code> is a type constructor that takes 1 parameter, which is what the
Functor typeclass expects.</p>
<p>Functions are in fact monads too:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">Applicative</span> <span class="p">((</span><span class="ow">-&gt;</span><span class="p">)</span> <span class="n">r</span><span class="p">)</span> <span class="kr">where</span>
    <span class="n">pure</span> <span class="n">x</span> <span class="ow">=</span> <span class="p">(</span><span class="nf">\</span><span class="kr">_</span> <span class="ow">-&gt;</span> <span class="n">x</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">&lt;*&gt;</span> <span class="n">g</span> <span class="ow">=</span> <span class="nf">\</span><span class="n">x</span> <span class="ow">-&gt;</span> <span class="n">f</span> <span class="n">x</span> <span class="p">(</span><span class="n">g</span> <span class="n">x</span><span class="p">)</span>

<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="p">(</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span> <span class="o">$</span> <span class="mi">5</span>
<span class="mi">508</span>
</code></pre></div><h2 id="in-action">In action</h2>
<p>Golfing once again&hellip;</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="c1">-- equivalently:</span>
<span class="c1">-- getZipList $ fmap (+) (ZipList [1,2,3]) &lt;*&gt; (ZipList [100,10,20])</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">getZipList</span> <span class="o">$</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="o">&lt;$&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="o">&lt;*&gt;</span> <span class="kt">ZipList</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="mi">101</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">23</span><span class="p">]</span>

<span class="c1">-- implicitly, this is (fmap &lt;$&gt; [(+2,(*2))]) &lt;*&gt; [Just 10, Just 20] :@1</span>
<span class="nf">ghci</span><span class="o">&gt;</span> <span class="n">fmap</span> <span class="o">&lt;$&gt;</span> <span class="p">[(</span><span class="o">+</span><span class="mi">2</span><span class="p">),(</span><span class="o">*</span><span class="mi">2</span><span class="p">)]</span> <span class="o">&lt;*&gt;</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">10</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">20</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">12</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">22</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">20</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">40</span><span class="p">]</span>

<span class="nf">ghci</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">fmap</span> <span class="p">(</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="o">&lt;$&gt;</span> <span class="p">[</span><span class="kt">Just</span> <span class="mi">1</span><span class="p">,</span> <span class="kt">Nothing</span><span class="p">,</span> <span class="kt">Just</span> <span class="mi">3</span><span class="p">]</span>
<span class="p">[</span><span class="kt">Just</span> <span class="mi">2</span><span class="p">,</span><span class="kt">Nothing</span><span class="p">,</span><span class="kt">Just</span> <span class="mi">6</span><span class="p">]</span>

</code></pre></div><h2 id="class-constraints">Class constraints</h2>
<p>Class constraints can appear in (type)class declarations vs instance
declarations, as in <code>(Eq m) =&gt; Eq (classOrInstanceName m)</code>.</p>
<ul>
<li>In class declarations, they are used for making a typeclass a subclass of
another typeclass.</li>
<li>In instance declarations, they are used to express requirements about the
contents of some type.</li>
</ul>
<p>For instance, we might require the contents of a Maybe, which is a concrete
type to also be part of the Eq typeclass. Note the Maybe is a type constructor.</p>
<h2 id="kinds">Kinds</h2>
<p><a href="https://en.wikipedia.org/wiki/Kind_(type_theory)">Few languages</a>
have type systems that allow access to higher-kinded types (e.g. Monads).
Haskell lets you see the kinds of types too.</p>
<p>Kinds are to types what types are to values. Find out kind of a type with
<code>:k</code> in GHCi.</p>
<p><code>*</code> means concrete type:</p>
<ul>
<li><code>Int :: *</code></li>
<li><code>Maybe :: * -&gt; *</code></li>
<li><code>Maybe Int :: *</code></li>
<li><code>Either :: * -&gt; * -&gt; *</code></li>
</ul>
<p>I haven&rsquo;t quite grasped this, but it&rsquo;s interesting regardless:</p>
<div class="highlight"><pre class="chroma"><code class="language-haskell" data-lang="haskell"><span class="kr">class</span> <span class="kt">Tofu</span> <span class="n">t</span> <span class="kr">where</span>
    <span class="n">tofu</span> <span class="ow">::</span> <span class="n">j</span> <span class="n">a</span> <span class="ow">-&gt;</span> <span class="n">t</span> <span class="n">a</span> <span class="n">j</span>
</code></pre></div><p>If <code>t</code> is an instance of <code>Tofu</code>, what would its kind be?</p>
<ul>
<li><code>j a</code> is the type of the value of the first parameter of <code>tofu</code>, so
its kind must be <code>*</code>, i.e. it is a concrete type.</li>
<li>Assuming <code>a</code> is of kind <code>*</code>, <code>j</code> has kind <code>* -&gt; *</code>.</li>
<li><code>t a j</code> must be a concrete type, and since it takes two types <code>a</code> and <code>j</code>,
whose kinds we inferred above, <code>t</code> has kind <code>* -&gt; (* -&gt; *) -&gt; *</code>.</li>
</ul>
<p>So, <code>t</code> takes a concrete type <code>a</code>, a type constructor <code>j</code> that takes a concrete
type, and produces a concrete type.</p>
</article>

        </main><footer id="footer">
    Copyright Â© 2020 Jonathan Jauhari
</footer>
</body>
</html>
