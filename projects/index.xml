<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Projects on Jonathan Jauhari</title>
    <link>https://jonjau.github.io/projects/</link>
    <description>Recent content in Projects on Jonathan Jauhari</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 31 Oct 2020 22:53:12 +1100</lastBuildDate>
    
	<atom:link href="https://jonjau.github.io/projects/index.xml" rel="self" type="application/rss+xml" />
    
    
    
    <item>
      <title>Making English More Regular With Esperanto Grammar</title>
      <link>https://jonjau.github.io/posts/making-english-more-regular-with-esperanto-grammar/</link>
      <pubDate>Sun, 27 Dec 2020 18:34:18 +1100</pubDate>
      
      <guid>https://jonjau.github.io/posts/making-english-more-regular-with-esperanto-grammar/</guid>
      <description>Some problems As a learner of English (who isn&amp;rsquo;t?), I&amp;rsquo;ve come across a lot of inconsistent rules and exceptions in the language, and I can imagine they exist in most other natural languages. People just (have to) get used to them. In general:
 Grammar is complex (13+ tenses!) and verb modification is irregular. Ambiguous semantics: the same sentence can mean different things. Spelling does not reflect pronunciation; accents vary wildly.</description>
    </item>
    
    
    
    <item>
      <title>The Visitor Pattern for Simple Collision Handling</title>
      <link>https://jonjau.github.io/posts/the-visitor-pattern-for-simple-collision-handling/</link>
      <pubDate>Fri, 20 Nov 2020 11:23:15 +1100</pubDate>
      
      <guid>https://jonjau.github.io/posts/the-visitor-pattern-for-simple-collision-handling/</guid>
      <description>Let&amp;rsquo;s say we were building a system where components can interact with other components, and based on the combination of components, some behaviour is to be expected. We must also assume the handled interactions are only between pairs.
A classic example is a pairwise collision system:
 Adventurers and beasts are creatures. Adventurers are either knights or archers. Beasts are either werewolves or (flying) dragons. When adventurers and beasts collide, they fight.</description>
    </item>
    
    
    
    
    
    <item>
      <title>A Sudoku Solver in 15 Lines of Prolog</title>
      <link>https://jonjau.github.io/posts/a-sudoku-solver-in-15-lines-of-prolog/</link>
      <pubDate>Mon, 26 Oct 2020 18:22:55 +1100</pubDate>
      
      <guid>https://jonjau.github.io/posts/a-sudoku-solver-in-15-lines-of-prolog/</guid>
      <description>The title says it all. I came across this Prolog code in a lecture recently, and it seems to come from here. If this isn&amp;rsquo;t peak abstraction, I don&amp;rsquo;t know what is.
Honestly though, can anyone even claim this is computer code? Seems to me like a line-by-line translation from the rules of Sudoku that actually runs (!!).
I&amp;rsquo;ve added some annotations below &amp;ndash; it really is just precise, plain, English.</description>
    </item>
    
    
    
    <item>
      <title>Monads, Applicatives, and Functors in Haskell</title>
      <link>https://jonjau.github.io/posts/monads-applicatives-and-functors-in-haskell/</link>
      <pubDate>Wed, 07 Oct 2020 22:31:10 +1100</pubDate>
      
      <guid>https://jonjau.github.io/posts/monads-applicatives-and-functors-in-haskell/</guid>
      <description>This is my summary of Chapter 11 and 12 of Learn You a Haskell for Great Good!, a great introduction to functional programming and Haskell. I&amp;rsquo;ve found its explanation of monads, by far the most notorious of category theory jargon (monoids and functors being runner-ups), to be about as intuitive as monad explanations can get.
This is hardly comprehensive, but these notes touch on most of the main concepts of the Haskell type system (that I&amp;rsquo;m aware of&amp;hellip;).</description>
    </item>
    
    
    
    
    
    
    
    
  </channel>
</rss>
